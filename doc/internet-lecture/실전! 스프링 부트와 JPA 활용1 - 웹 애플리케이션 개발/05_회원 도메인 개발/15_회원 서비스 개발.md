## 회원 서비스 개발
- persist
  - 영속성 컨텍스트에 올라간다. 
  - 키와 밸류 중 키가 아이디가 된다.
  - 키가 PK에 들어가고 변수 id에 값을 채워 준다. 따라서 꺼내지 않아도 id 값이 보장된다.???
- List 객체 null 체크 -> isEmpty() 사용
- JPA의 모든 데이터 변경이나 로직은 가급적 트랜잭션 안에서 다 실행 되어야 한다. 따라서 Service에 @Transactional() 추가
  - 클래스 레벨에서 사용하면 퍼블릭 메소드들은 다 트랜잭션이 사용 된다. (스프링 제공)
  - 스프링 제공 트랜잭션을 사용해야 쓸 수 있는 것들이 많다.
  - @Transactional(readOnly = true) 조회에서 조금 더 성능을 최적화 해준다. (더티 체킹, DB에 따른 읽기전용 트랜잭션이면, 리소스 많이 쓰지마라 하는 드라이버가 있다.)
    - 읽기에는 readOnly 넣어주는게 좋다.
    - 읽기가 많은 클래스는, 클래스 레벨에서 readOnly를 주고 따로 쓰기 메서드에 @Transactional을 준다. 그 반대는 반대로..
- 회원 가입에서 두 사람이 같은 시간에 같은 아이디로 가입을 할 수 있는 걸 막기 위해 회원의 Name을 유니크 제약조건으로 잡아주는 걸 권장한다. (멀티 쓰레드 환경)
- 필드 Autowired 대체하자!!!
  - 단점이 많다... 
  - setter Injection -> 스프링이 바로 주입이 아니라, (@Autowired 셋터에...) 셋터를 통해 하는 방법도 있다. 테스트 코드 작성시 Mock에 직접 주입 가능한 장점이 잇다. 필드는 주입하기가 까다롭다.
    - 애플리케이션 돌아가는 시점에 셋터를 통해 바꿀 수 있다... 단점!! 
    - 궁극적으로 권장 방식은 생성자 인잭션 사용!! -> 생성자에 Autowired~ 스프링이 생성자에서 인잭션을 해준다. 중간에 바꿀 방법이 없어서 좋다. 그리고 테스트 케이스 작성 시 생성자 오토와이어를 직접 주입을 해줘야 해서 컴파일 체크 가능
      - 코드가 번거롭기 때문에, 최신 버전 스프링 부트에서는 생성자가 하나만 있는 경우 Autowired를 생략해도 주입 해준다. 
      - 리포지토리는 final로 하기를 권장!! 컴파일 시점에 체크 가능!
      - 여기다가 롬복을 적용!!!! -> @AllArgsConstructor!!! 
      - 얘보다 한 단계 나은게 뭐냐면!!!!!!! @RequiredArgsConstructor 얘는 final 필드만 생성자로 만들어준다.
      - 스프링 부트, 스프링 라이브러리를 사용 시 EntityManager를 @PersistenceContext 대신 @Autowired를 써도 인식 해준다! 그러면 또 @RequiredArgsConstructor를 사용 하여 코드를 줄이고 효율적으로 사용 가능 