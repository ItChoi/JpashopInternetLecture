## API 개발 고급 정리
- 엔티티 조회
  - 엔티티 조회 후 그대로 반환 V1
    - 사용 X, 스펙이 바뀐다.
  - 엔티티 조회 후 DTO로 변환 V2
    - API 스펙에 맞게 변환해서 반환!
    - V1, V2 성능이 안나올 때가 있는데, 이때 페치 조인! 
  - 페치 조인으로 쿼리 수 최적화 V3
    - 페치 조인의 한계 -> 컬렉션의 경우 페이징이 안된다.
  - 컬렉션 페이징과 한계 돌파 V3.1
    - 컬렉션은 페치 조인 시 페이징 불가능
    - ToOne 관계는 페치 종니으로 쿼리 수 최적화
    - 컬렉션은 페치 조인 대신 지연 로딩을 유지하고, hibetnate.default_batch_fetch_size, @BatchSize로 최적화    
    
- DTO 직접 조회
  - JPA에서 DTO를 직접 조회 V4
  - 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회 후 최적화 V5
  - 플랫 데이터 최적화 - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환 V6

- 권장 순서
  1. 엔티티 조회 방식으로 우선 접근
    - 페치 조인으로 쿼리 수 최적화
    - 컬렉션 최적화
      - batchSize 최적화
      - 페이징 필요 X -> 페치 조인 사용
  2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
  3. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate
  
- 엔티티는 캐시로 관리 X
  - 영속성 컨텍스트로 인해 꼬일 수 있다.
  - 캐시는 무조건 DTO로 변환해서 DTO로!
  
- DTO 조회 방식의 선택지
  - 성능 최적화와 코드 복잡도 사이의 트레이드 오프!
  - 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해준다.
  - DTO 조회 방식은 SQL 직접 다루는 것과 유사하기 때매 둘 사이의 트레이드 오프가 필요하다
  
- DTO 조회 방식의 선택지
  - 상황에 맞게 쓰자~