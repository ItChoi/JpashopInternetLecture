## 주문 조회 V3 엔티티를 DTO로 변환 - 페치 조인 최적화
- Order가 2개 OrderItem이 각 2개씩 4개라면 fetch join 시 4개의 데이터가 나온다. 주의!
  - 1이랑 N이 있으면 N만큼 데이터가 뻥튀기가 된다. -> 의도랑은 다른 값이 나온다.
  - fetch join 시 distinct sql의 distinct 기능을 해준다. 그런데 문제가 있다.
    - DB의 distinct는 전부 똑같아야 중복 제거인데, JPA의 distinct는 데이터가 달라도 중복 제거를 해준다! 
    - JPA의 distinct는 Id값이 같으면 중복제거를 해준다.
      - DB distinct 키워드를 날려주고, 엔티티가 중복인 경우 중복을 제거해서 리스트에 담아준다.
- 커넥션 fetch 조인과 일반 fetch 조인의 차이!
  - 페치 조인으로 SQL이 한 번만 실행되는 장점!
  - distinct의 어마어마한 단점 -> 페이징 불가능!!!!!!!!
    - 1:N를 페치 조인 하는 순간 페이징이 안나간다!!!!!!!!!!!
    - 워닝 로그를 잘 보자!
    - 메모리에서 페이징 처리를 한다! 10000개가 있을 때, 애플리케이션에 넣고 돌린다. out of memory!
    - 1:N 조인하는 순간 엔티티의 기준 자체가 틀어진다. -> 뻥티기를 기준으로 페이징이 된다. Order 데이터를 못 맞춘다.
    - 1:N 페치 조인에서는 페이징 절대 하지 말자!!!
      - 1:N가 아닌 경우 상관 없다.
- 컬렉션 페치 조인은 1개만 사용할 수 있다.
  - 둘 이상 사용 시 데이터가 부정확하게 조회될 수 있다