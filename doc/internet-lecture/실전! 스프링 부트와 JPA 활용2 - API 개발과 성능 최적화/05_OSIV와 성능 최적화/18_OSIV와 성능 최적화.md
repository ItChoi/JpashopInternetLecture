## OSIV와 성능 최적화
- Open Session In View: 하이버네이트
- Open EntityManager In View: JPA (관례상 OSIV라 한다.)
- 엔티티 매니저가 하이버네이트에서는 Session!
- 모르면 장애로 이어질 수 있다 -> 트래픽이 많은 서비스는 명확한 이해가 필요하다.
- 최신 스프링 부트 사용 시 실행하면(2점대) warn 메시지가 하나 뜬다.
  - spring.jpa.open-in-view -> default (enable) -> 그러므로 디비 쿼리가 뷰가 렌더링될 때 까지 수행 되고 머시기 머시기 경고가 뜬다!
  - 워닝 로그를 남기는 이유가 있다!
- 기본적으로 DB 트랜잭션이 시작될 때 JPA 영속성 컨텍스트가 DB 커넥션을 가져온다. 
  - DB에 돌려주는 시점이 spring.jpa.open-in-view ture/false에 따라 다르다.
    - true: 트랜잭션이 끝나고 바깥으로 나갈 때(?) 까지 반환안한다. -> 컨트롤러에서 유지하여 레이지 로딩 등 사용 가능함, 영속성 컨텍스트가 DB를 물고 계속 살아있어야 한다.
      - api의 경우 유저한테 반환할 때 까지 살아있다. (영속성 컨텍스트, DB 커넥션이 살아있다)
      - 뷰 템플릿은 렌더링되고 데이터 리스폰스가 나갈때 까지!!
      - 지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 DB 커넥션을 유지한다. 그런데 너무 오랫동안 DB 커넥션 리소스를 사용하기에 실시간 트래픽이 중요한 App에는 커넥션이 모자를 수 있다.
      - 만약 컨트롤러에서 외부 API 호출 시, 3초 걸린다 하면, DB 커넥션도 고객에게 응답준 것이 아니기 때문에, DB 커넥션을 쓰고 있는거다.
      - 개발 입장에서는 중복도 줄이고 투명하게 레이지 로딩 가능! 유지 보수성을 높이는 장점!
      - 치명적인 단점이 DB 커넥션을 오래 물고 있는다...
    - false: 트랜잭션이 시작되고 끝날 때 까지만, 영속성 컨텍스트와 DB 커넥션을 유지한다.
      - DB 커넥션을 짧게 유지한다.
      - flush close, 영속성 컨텍스트를 날려버린다.
      - 커넥션 리소스를 낭비하지 않는다.
      - 치명적인 단점은 OSIV를 끄면 모든 지연 로딩을 트랜잭션 안에서 처리, 따라서 지연로딩 끝나기 전에 지연로딩을 강제로 호출해서 사용해야 한다.
      - false로 할 시 LazyInitializationException: could not initialize proxy를 겁나 만나게 될 것이다. 
      - 트랜잭션 안에서 지연로딩을 하거나, 페치 조인을 사용해야 한다.
- 권장 방법
  - OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법이 있다.
    - Command와 Query를 분리하는 것!
    - 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞춰 성능을 최적화하는 것이 중요하다. 하지만 그 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 아니다.
      - OrderService: 핵심 비즈니스 로직 (어플리케이션이 작으면 이거만..) 
      - OrderQueryService: 화면이나 API에 맞춘 서비스 (주로 읽기 전용 트랜잭션 사용) (점점 커지면 이거도 사용)
        - 아키텍쳐에 따라 계층을 한 단계 더 가져가는 경우도 있다. 그 경우에 따라 트랜잭션을 어디만 유지할건지 어디만 유지할건지 선택지가 생긴다.
  - OSIV 켜면 쿼리 서비스를 안 만들고 컨트롤러에서나 어디서든 할 수 있기 때문에 장점이 크다.
  - 유지보수성만 생각하면 OSIV 키는 것의 장점이 크다, 성능 생각하면 끈다.
  - 김영한님은 고객 서비스 트래픽이 많은 실시간 API는 OSIV를 끄고, ADMIN처럼 커넥션이 많이 사용하지 않는 곳에서는 OSIV 켠다
  - 따라서 상황에 맞게 설정하자
    